Paperclips: The Networked Multiplayer Game To End Them All

Features we want:

- Asynchrony. We want clients to be able to pull down all their
	involved games in the background, and for the user to be able to
	interact with them instantly. No network round trips on the user
	workflow's critical path.
- Reliability. This has a couple parts:
	- We don't want to lose games or moves serverside at all.
	- Once data has been confirmed by the server, it shouldn't be lost,
    ever.
	- Clients should store and forward their moves. They should never be
    dropped on the floor unless the device fails or if they are being
    made from an out-of-date game state. The latter doesn't happen
    much because clients won't usually be playing from multiple
    computers at once, so blackholing is a perfectly fine strategy for
    a rare occurrence. Heck, you could even error out.


CORE DATA MODEL:

Board: a game state. Has the following entries:
 - Number of paperclips
 - List of players
 - Whose turn it is
 - Winner, if any
 - Move history?
 - Board ID

Move: a move to be applied
 - Originating player ID
 - Originating board ID
 - Move description (paperclip count, 1 or 2)


RPC Methods:
- GetGames(Player): Returns the current games list for Player
- MakeMove(Board, Move):
  Makes the given move on the given board, if possible.

  Return values:
    err: if nil, everything is great
      Otherwise, returns an error. Probably something out of
			these:
			- Move is against an old board state. Client should drop the
        move and optionally notify of a conflict.
			- Move is bad. Client validation should have caught this, but a
			  "screw you, clown" from the server is appropriate here.
			- Move was not made. Client should store it and try again later.

- Poll(Player): Sit around and wait until the server has a state
  update to send us. When it does, this method returns
  immediately. This is useful for writing AIs and other things that
  wish to react immediately to a server state change.

	Design: The above is somewhat complicated to implement. The general
	idea is that, for each Player, we want to have a queue of updates
	that need to be pushed. The queue should not contain duplicate
	entries and is this implemented as a set.

	TODO: Does the Poll() method need to support multiple concurrent
	pollers? .... probably....

	TODO: Should Poll() return one (or a list of) update(s) immediately,
	or is a simple signal that "something is up" sufficient?

	The queues are implemented as Mailbox objects. The job of a Mailbox
	is to accept incoming messages, deduplicate them against what's
	waiting, and respond to Poll() requests. A Poll() request will
	immediately return if any messages have accumulated since the last
	Poll(), and otherwise will block until some arrive.

	At least, that's the theory. I think this is not a good design.

	Weaknesses:
	- Multiple clients on the same Player.
	- What about the time between when you download the user data and
    the moment you start the Long Poll?


Servers, round 1:
Game server:
- Implements the RPC methods
- Persists data in-memory (hah!)

TODO: Persistent storage, reliability engineering.